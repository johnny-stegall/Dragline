@{
  ViewBag.Title = "Infinite Scrolling Unit Tests";
}

@section Styles
{
  @*
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/qunit/1.16.0/qunit.min.css" />
  *@
}

@section Scripts
{
  @*
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/qunit/1.16.0/qunit.min.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/blanket.js/1.1.4/blanket.min.js"></script>
  *@
}

@*
  <div id="qunit"></div>
*@

<table class="Hot-Tracking">
  <thead>
    <tr>
      <th>Column 1</th>
      <th>Column 2</th>
      <th>Column 3</th>
      <th>Column 4</th>
      <th>Column 5</th>
    </tr>
  </thead>
  <tbody data-bind="foreach: TableItems">
    <tr>
      <td data-bind="text: $data['Column 1']"></td>
      <td data-bind="text: $data['Column 2']"></td>
      <td data-bind="text: $data['Column 3']"></td>
      <td data-bind="text: $data['Column 4']"></td>
      <td data-bind="text: $data['Column 5']"></td>
    </tr>
  </tbody>
</table>

<ol data-bind="foreach: ListItems"></ol>

<script type="text/javascript" src="~/scripts/dragline/jQuery/infinite-scroll.js"></script>
<script type="text/javascript">
  var Setup =
  {
    ViewModel:
    {
      Items: ko.observableArray(),
      ListItems: ko.observableArray([]),
      TableItems: ko.observableArray([])
    },

    addItems: function(pageIndex, pageSize)
    {
      pageIndex = pageIndex || 0;
      pageSize = pageSize || 25;

      var newItems = [];
      var startIndex = pageIndex * pageSize;

      for (var rowIndex = startIndex; rowIndex < startIndex + pageSize; rowIndex++)
      {
        var newItem = {};

        for (var columnIndex = 0; columnIndex < 5; columnIndex++)
          newItem["Column " + (columnIndex + 1)] = "Item " + (rowIndex + 1) + "-" + (columnIndex + 1);

        newItems.push(newItem);
      }

      Setup.ViewModel.Items().concat(newItems);
      return newItems;
    },

    getDataForTable: function(pageIndex, pageSize)
    {
      var newItems = Setup.addItems(pageIndex, pageSize);
      $("table").InfiniteScroll("cacheData", newItems);
    },

    tablePagingCallback: function(data)
    {
      Setup.ViewModel.TableItems(data);
    }
  };

  $(document).ready(function()
  {
    // This is what developers must do to initialize infinite scrolling
    var table = $("table");
    table.InfiniteScroll(
    {
      DataCallback: Setup.getDataForTable,
      PagingCallback: Setup.tablePagingCallback
    });

    ko.applyBindings(Setup.ViewModel, table[0]);

    var newItems = Setup.addItems();
    Setup.ViewModel.TableItems(newItems);
    $("table").InfiniteScroll("cacheData", newItems);
  });

  /****************************************************************************
  * Cleanup after each test.
  ****************************************************************************/
  //QUnit.testDone(function()
  //{
  //  var infiniteScrollers = $("div.Infinite-Scroll");
  //  infiniteScrollers.AdapTable("destroy");

  //  for (var scrollerIndex = 0; scrollerIndex < infiniteScrollers.length; scrollerIndex++)
  //    ko.cleanNode(infiniteScrollers[scrollerIndex]);

  //  sessionStorage.clear();
  //});

  //QUnit.test("Infinite Scrolling Window-Viewport Constructor", function(assert)
  //{
  //  // Arrange
  //  var table = $("table");
  //  ko.applyBindings(ViewModel, table[0]);

  //  var newItems = Setup.addItems();
  //  Setup.ViewModel.TableItems(newItems);

  //  // Act
  //  table.InfiniteScroll(
  //  {
  //    DataCallback: Setup.getDataForTable,
  //    PagingCallback: Setup.tablePagingCallback
  //  });

  //  $("table").InfiniteScroll("cacheData", newItems);

  //  // Assert
  //  var container = table.parent();
  //  assert.equal(container.prop("tagName").toUpperCase(), "DIV");
  //  assert.ok(container.hasClass("Infinite-Scroll"));

  //  var topSpacer = container.children(":first");
  //  assert.ok(topSpacer.prop("tagName"), "SECTION");

  //  var bottomSpacer = container.children(":last");
  //  assert.ok(bottomSpacer.prop("tagName"), "SECTION");
  //});
</script>
