@{
    ViewBag.Title = "Patterns";
}

<ul id="ulContents" style="padding-left: 20px; position: fixed; right: 0; top: 60px;" class="Unstyled Width-25"></ul>

<div class="Width-75">
  <h1>Patterns</h1>

  <article>
    <h2 id="JavaScript">JavaScript</h2>

    <p>
      JavaScript is a prototype-based scripting language with dynamic typing
      and first-class functions; JavaScript has only two scopes: global and
      functions (local). Because of this, it is important to have defined
      patterns for techniques such as namespacing.
    </p>

    <h3 id="Unobtrusive">Unobtrusive</h3>

    <p>
      Since the early days of the web and JavaScript, developers have been able
      to embed JavaScript in web pages. The current best practices are a set of
      principles known as <em>Unobtrusive JavaScript</em>.
    </p>

    <h4 id="Separation">Separation</h4>

    <p>
      Separation is the practice of separating the behavior layer (JavaScript)
      from the presentation layer (HTML, CSS, content). In early days of the
      web developers placed JavaScript in <code>&lt;script&gt;</code> tags or
      even sometimes within attributes of some HTML elements. This is frowned
      upon. JavaScript should be placed in its own .js files whenever possible.
    </p>

    <h5 id="Hyperlinks">Hyperlinks</h5>

    <p>
      One exception to the rule is placing <code>javascript:void();</code> in
      the <code>href</code> attribute of an <code>&lt;a&gt;</code> element.
      This is still considered acceptable practice, although other function
      calls or JavaScript should not be placed in <code>href</code>.
    </p>

    <h5 id="EventHandlers">Event Handlers</h5>

    <p>
      Even though HTML still supports event-handler attributes (e.g.
      <code>onchange</code> or <code>onclick</code>), they should never be
      used.
    </p>

    <h4 id="GracefulDegradation">Graceful Degradation</h4>

    <p>
      JavaScripts should never generate error messages - in any browser - even
      when they fail. If a browser does not support a feature, the script
      should implement a fallback approach or fail silently.
    </p>

    <h4 id="Usability">Usability</h4>

    <p>
      Unobtrusive JavaScript never draws attention to the user. Visitors should
      use it without thinking about it.
    </p>

    <h4 id="Defensive">Be Defensive</h4>

    <p>
      Always program assuming JavaScript will be disabled by the browser or a
      plugin at any time, or will not run for some other reason (lack of
      browser support, changes to the HTML DOM, global namespace encroachment,
      etc.)
    </p>

    <h4 id="Traversal">Traversal</h4>

    <p>
      Leave traversing individual DOM objects to the experts, such as the CSS
      handler built into the browser where possible.
    </p>

    <h4 id="ProgressiveEnhancement">Progressive Enhancement</h4>

    <p>
      While it might seem counter intuitive, progressive enhancement and
      graceful degradation do not conflict. Before starting any work, define
      the minimum browsers to support. When newer browsers are released, their
      features can be supported, as long as fallbacks exist for the minimally
      supported browsers. A user on a minimally supported browser should never
      miss out on functionality, but it's okay for their experience to be
      diminished.
    </p>

    <h3 id="Namespacing">Namespacing</h3>

    <p>
      Namespacing is a technique used to avoid collisions with other objects,
      functions, and variables in the global namespace. It's also useful for
      organizing blocks of functionality in an application.
    </p>

    <p>
      In JavaScript, namespacing is critical to any application - and at the
      enterprise level - because it's the only means for safeguarding code
      from breaking in the event another script on the page uses the same
      variable or method names. Except that JavaScript doesn't actually have
      built-in support for namespaces. What it does have is closures and
      objects which can be used to achieve a similar effect.
    </p>

    <p>
      While various patterns for JavaScript namespacing exist, the preferred
      method is using object literal notation. Object literal notation has no
      disadvantages as other patterns do and has the added advantage of not
      polluting the global namespace. 
    </p>

<pre>
var Namespace =
{
};
</pre>

    <h4 id="NestedNamespacing">Nested Namespacing</h4>

    <p>
      Nested namespaces can easily be accomplished using the object literal
      pattern. When using nested namespaces, always check to make sure the
      parent namespace doesn't already exist.
    </p>

<pre>
var WoltersKluwer = WoltersKluwer || {};
WoltersKluwer.Nested =
{
};
</pre>
  </article>

  <article>
    <h2 id="Knockout">Knockout</h2>

    <p>
      Knockout is a powerful library for declarative databinding, but with that
      comes the potential for great abuse.
    </p>

    <h3 id="Functions">Functions</h3>

    <p>
      Function calls in a binding should be avoided. Instead consider creating
      a custom binding that calls the method.
    </p>

    <h3 id="Conditions">Conditions</h3>

    <p>
      Conditional statements in databindings should be simple and easy to read.
      Avoid using multiple conditions in a single databinding in favor of a
      custom binding.
    </p>

    <h3 id="ElementWrapping">Element Wrapping</h3>

    <p>
      Avoid creating container elements just for a databinding condition;
      instead take advantage of Knockout's comment binding.
    </p>
  </article>

  <article>
    <h2 id="jQuery Plugins">jQuery Plugins</h2>

    <p>
      jQuery plugins can transform HTML elements and greatly enhance user
      experience and functionality. When creating jQuery plugins, the preferred
      method is using the recommended jQuery patterns.
    </p>

    <h3 id="ElementPlugins">Plugins that Operate on Elements</h3>

<pre>
// This is another form of namespacing known as an IIFE
// (Immediately Invoked Function Expression)
(function($)
{
  var PluginObject = function(element, options)
  {
    // Private methods go here
  }

  $.fn.Plugin = function()
  {
    // Dictionary of default settings goes here
    var settings = $.extend(
    {
    }, options);
    
    // Return this to allow for method chaining
    return this.each(function()
    {
      // The element is wrapped in jQuery before sending to the plugin
      new PluginObject($(this), settings);
    });
  };
})(jQuery);
</pre>

    <h4 id="DeclarativeInstantiation">Declaration Instantiation</h4>

    <p>
      If a plugin can be instantiated declaratively (using attributes or CSS
      classes), then the following code should be added to the bottom of
      the plugin script file.
    </p>

<pre>
$(document).ready(function()
{
  // Allow declarative activation
  $("[data-counter]").each(function()
  {
    var self = $(this);

    var options = self.data("options");
    if (options && typeof (options) === "string")
      options = JSON.parse(options.replace(/'/g, "\""));

    self.Plugin(options);
  });
});
</pre>

    <h3 id="">Element-less Plugins</h3>

<pre>
(function($)
{
  // Note that it's not a function, but an object literal
  var PluginObject =
  {
    // Private methods go here
  }

  $.fn.Plugin = function()
  {
    // Return this to allow for method chaining
    return this.each(function()
    {
      new PluginObject(this);
    });
  };

  $.Plugin =
  {
    // This is the public method namespace
  }
})(jQuery);
</pre>
  </article>
</div>

<script type="text/javascript">
  $("#ulContents").Index({ Offset: 60 });
</script>